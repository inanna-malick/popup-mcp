// Simple, unified popup grammar with intelligent value recognition
// The grammar focuses on structure; the parser handles interpretation

// ============================================
// WHITESPACE - Pest handles this automatically between tokens
// ============================================

WHITESPACE = _{ " " | "\t" | "\r\n" | "\n" }

// ============================================
// ROOT
// ============================================

popup = { SOI ~ element* ~ EOI }

// ============================================
// ELEMENTS - Things that appear after the title
// ============================================

element = {
    // Conditional blocks MUST be checked first before bracket buttons
    conditional
    // Button patterns (including bracket buttons)
    | buttons
    // Messages with prefix
    | message
    // Labeled items that might be widgets
    | labeled_item
    // Multi-line text block
    | text_block
}

// Text block - just a single text line for now
text_block = {
    text_line
}

// Labeled item: "Label: value" - parser decides if it's a widget or text
labeled_item = {
    label ~ ":" ~ item_value
}

label = @{ (!(":" | "\n" | "\r") ~ ANY)+ }

// The value part - parser will interpret based on pattern
item_value = @{ 
    textbox_value |
    boolean_value | 
    range_value | 
    choice_value | 
    plain_value 
}

// Textbox pattern starts with @
textbox_value = @{ "@" ~ (!("\n" | "\r") ~ ANY)* }

// Plain value - anything that's not a newline
plain_value = @{ (!("\n" | "\r") ~ ANY)+ }

// VIBES: Make invalid boolean states impossible to express
boolean_value = @{ 
    (^"yes" | ^"no" | ^"true" | ^"false" | ^"enabled" | ^"disabled" | 
     ^"on" | ^"off" | "✓" | "☐" | "[x]" | "[ ]" | "(*)" | "( )")
}

// VIBES: Make invalid number ranges impossible to express  
range_value = @{ ASCII_DIGIT+ ~ (" "* ~ ("-" | ".." | "to") ~ " "*) ~ ASCII_DIGIT+ ~ (" "* ~ "=" ~ " "* ~ ASCII_DIGIT+)? }

// Button patterns - various formats
buttons = {
    // [OK | Cancel]
    bracket_buttons
    // → Continue
    | arrow_button
    // Yes or No
    | or_buttons
}

bracket_buttons = {
    "[" ~ !("if") ~ button_text ~ ("|" ~ button_text)* ~ "]"
}

arrow_button = {
    "→" ~ button_text
}

or_buttons = {
    button_text ~ ("or" ~ button_text)+
}

button_text = @{ 
    (!("|" | "]" | "\n" | "\r" | " or ") ~ ANY)+
}

// VIBES: Make empty choice options impossible to express
choice_value = @{ choice_option ~ (" "* ~ "|" ~ " "* ~ choice_option)+ }
choice_option = @{ (!"|" ~ !"," ~ !"]" ~ !("\n" | "\r") ~ ANY)+ }

// Messages - lines starting with specific prefixes
message = {
    message_prefix ~ text_line
}

message_prefix = { ">" | "!" | "?" | "•" }

// Generic text line
text_line = @{ (!("\n" | "\r") ~ ANY)+ }

// ============================================
// CONDITIONAL BLOCKS
// ============================================

// Conditional with nested brace support
// Use atomic rule to match the full structure, let parser handle the details
conditional = @{
    "[if " ~ (!"]" ~ ANY)+ ~ "] {" ~ conditional_body ~ "}"
}

// Body can contain any characters including nested braces
conditional_body = @{
    (
        // Match anything that's not a brace
        (!("{" | "}") ~ ANY)
        // Or match nested brace pairs
        | ("{" ~ conditional_body ~ "}")
    )*
}

condition = { condition_text }

// Most basic: just match everything until ]
condition_text = @{ (!"]" ~ ANY)+ }