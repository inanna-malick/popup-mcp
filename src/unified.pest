// Unified Popup DSL Grammar
// One flexible grammar with micro-level flexibility

// ============================================
// WHITESPACE & COMMENTS
// ============================================

WHITESPACE = _{ " " | "\t" }
NEWLINE = _{ "\r\n" | "\n" }
ws = _{ WHITESPACE* }
COMMENT = _{ ("#" | "//") ~ (!NEWLINE ~ ANY)* }

// ============================================
// ROOT - Single unified structure
// ============================================

popup = { SOI ~ ws ~ title_line ~ ws ~ body? ~ ws ~ EOI }

// Title can be standalone or with a colon
title_line = {
    title ~ ws? ~ ":"? ~ ws? ~ NEWLINE?
}

// Title is flexible - can include "confirm" prefix
title = {
    ("confirm" ~ ws)? ~ title_text
}

// Body is just a series of elements
body = { 
    (element ~ (ws? ~ NEWLINE* ~ ws? ~ element)*)?
}

// ============================================
// ELEMENTS - All the things you can put in a popup
// ============================================

element = {
    // Widgets with flexible syntax
    widget
    // Buttons with multiple formats
    | buttons  
    // Conditional blocks
    | conditional
    // Section headers
    | section
    // Standalone text/messages
    | message
}

// ============================================
// WIDGETS - Flexible recognition
// ============================================

widget = {
    // "Label: value" format - infers widget type from value
    label ~ ws? ~ ":" ~ ws? ~ widget_value
}

label = @{ (!(":" | NEWLINE) ~ ANY)+ }

widget_value = {
    // Range patterns → Slider
    range_value
    // Boolean patterns → Checkbox  
    | boolean_value
    // Choice patterns → Choice or Multiselect
    | choice_value
    // Text input → Textbox
    | textbox_value
    // Fallback → Text display
    | text_value
}

// Range: "0-100", "0..100", "0 to 100" with optional default
range_value = {
    number ~ ws? ~ (".." | "-" | "to") ~ ws? ~ number ~ 
    (ws? ~ ("=" | "default") ~ ws? ~ number)?
}

// Boolean: "yes", "✓", "[x]", etc.
boolean_value = {
    "yes" | "no" | "true" | "false" | "on" | "off" |
    "✓" | "✗" | "☐" | "☑" | "☒" |
    "[x]" | "[X]" | "[ ]" | "(*)" | "( )"
}

// Choice: "A | B | C" or "[A, B, C]"
choice_value = {
    // Multi-select format
    "[" ~ ws? ~ choice_item ~ (ws? ~ "," ~ ws? ~ choice_item)* ~ ws? ~ "]"
    // Single choice format
    | choice_item ~ (ws? ~ "|" ~ ws? ~ choice_item)+
}

choice_item = { quoted_string | choice_text }
choice_text = @{ (!("|" | "," | "[" | "]" | NEWLINE) ~ ANY)+ }

// Textbox: "@placeholder"
textbox_value = {
    "@" ~ text_value?
}

// ============================================
// BUTTONS - Multiple flexible formats
// ============================================

buttons = {
    // Natural language: "with Yes or No"
    natural_buttons
    // Bracket format: "[OK | Cancel]"
    | bracket_buttons
    // Arrow format: "→ Continue"  
    | arrow_button
    // Explicit: "buttons: [OK, Cancel]"
    | explicit_buttons
    // Separator line: "---" followed by buttons
    | separator_buttons
    // Standalone: "OK or Cancel"
    | standalone_buttons
}

natural_buttons = {
    ("with" | "using") ~ ws ~ button_text ~ (ws ~ "or" ~ ws ~ button_text)+
}

bracket_buttons = {
    "[" ~ ws? ~ button_text ~ (ws? ~ ("|" | ",") ~ ws? ~ button_text)* ~ ws? ~ "]"
}

arrow_button = {
    "→" ~ ws ~ button_text
}

explicit_buttons = {
    ("buttons" | "actions") ~ ws? ~ ":" ~ ws? ~ 
    (bracket_buttons | (button_text ~ (ws ~ "or" ~ ws ~ button_text)*))
}

separator_buttons = {
    "---" ~ ws? ~ NEWLINE ~ ws? ~
    button_text ~ (ws? ~ "|" ~ ws? ~ button_text)*
}

standalone_buttons = {
    button_text ~ ws ~ "or" ~ ws ~ button_text ~ (ws ~ "or" ~ ws ~ button_text)*
}

button_text = { quoted_string | button_unquoted }
button_unquoted = @{ 
    // For "or" separated buttons, stop at " or "
    (!(" or " | "|" | "," | "[" | "]" | NEWLINE) ~ ANY)+
}

// ============================================
// CONDITIONALS
// ============================================

conditional = {
    ("when" | "if") ~ ws ~ condition ~ ws? ~ ":" ~ ws? ~ NEWLINE? ~
    conditional_body
}

condition = {
    // "field = value"
    field_name ~ ws? ~ "=" ~ ws? ~ field_value
    // "field > number"
    | field_name ~ ws? ~ (">" | "<" | ">=" | "<=") ~ ws? ~ number
    // "field" or "field?"
    | field_name ~ ws? ~ "?"?
}

field_name = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_" | "-" | " ")* }
field_value = { quoted_string | word }

conditional_body = {
    PUSH(WHITESPACE+) ~ body ~ DROP
}

// ============================================
// SECTIONS & MESSAGES
// ============================================

section = {
    "---" ~ ws? ~ section_title ~ ws? ~ "---" ~ ws? ~ NEWLINE
}

section_title = @{ (!("---" | NEWLINE) ~ ANY)+ }

message = {
    // Prefixed messages
    message_prefix ~ ws ~ text_value
    // Plain text line
    | text_value
}

message_prefix = { ">" | "!" | "?" | "•" }

// ============================================
// BASIC VALUES
// ============================================

text_value = { quoted_string | unquoted_text }

quoted_string = {
    "\"" ~ inner_string ~ "\""
    | "'" ~ inner_string ~ "'"
}

inner_string = @{ (!("\"" | "'") ~ ANY)* }

unquoted_text = @{ (!NEWLINE ~ ANY)+ }

// Title text stops at colon or newline
title_text = { quoted_string | title_unquoted }
title_unquoted = @{ (!(":" | NEWLINE) ~ ANY)+ }

word = @{ (ASCII_ALPHANUMERIC | "_" | "-")+ }
number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }